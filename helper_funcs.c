/*
 * helper_funcs.c
 *
 * Created: 4/14/2024 12:12:29 AM
 *  Author: Jake
 */ 
#include <avr/io.h>
#include <avr/interrupt.h>
#include "helper_funcs.h"

// Lookup table for sine wave generation
uint16_t lookupTable[256] = {
    0x800, 0x832, 0x864, 0x896, 0x8c8, 0x8fa, 0x92c, 0x95e,
    0x98f, 0x9c0, 0x9f1, 0xa22, 0xa52, 0xa82, 0xab1, 0xae0,
    0xb0f, 0xb3d, 0xb6b, 0xb98, 0xbc5, 0xbf1, 0xc1c, 0xc47,
    0xc71, 0xc9a, 0xcc3, 0xceb, 0xd12, 0xd39, 0xd5f, 0xd83,
    0xda7, 0xdca, 0xded, 0xe0e, 0xe2e, 0xe4e, 0xe6c, 0xe8a,
    0xea6, 0xec1, 0xedc, 0xef5, 0xf0d, 0xf24, 0xf3a, 0xf4f,
    0xf63, 0xf76, 0xf87, 0xf98, 0xfa7, 0xfb5, 0xfc2, 0xfcd,
    0xfd8, 0xfe1, 0xfe9, 0xff0, 0xff5, 0xff9, 0xffd, 0xffe,
    0xfff, 0xffe, 0xffd, 0xff9, 0xff5, 0xff0, 0xfe9, 0xfe1,
    0xfd8, 0xfcd, 0xfc2, 0xfb5, 0xfa7, 0xf98, 0xf87, 0xf76,
    0xf63, 0xf4f, 0xf3a, 0xf24, 0xf0d, 0xef5, 0xedc, 0xec1,
    0xea6, 0xe8a, 0xe6c, 0xe4e, 0xe2e, 0xe0e, 0xded, 0xdca,
    0xda7, 0xd83, 0xd5f, 0xd39, 0xd12, 0xceb, 0xcc3, 0xc9a,
    0xc71, 0xc47, 0xc1c, 0xbf1, 0xbc5, 0xb98, 0xb6b, 0xb3d,
    0xb0f, 0xae0, 0xab1, 0xa82, 0xa52, 0xa22, 0x9f1, 0x9c0,
    0x98f, 0x95e, 0x92c, 0x8fa, 0x8c8, 0x896, 0x864, 0x832,
    0x800, 0x7cd, 0x79b, 0x769, 0x737, 0x705, 0x6d3, 0x6a1,
    0x670, 0x63f, 0x60e, 0x5dd, 0x5ad, 0x57d, 0x54e, 0x51f,
    0x4f0, 0x4c2, 0x494, 0x467, 0x43a, 0x40e, 0x3e3, 0x3b8,
    0x38e, 0x365, 0x33c, 0x314, 0x2ed, 0x2c6, 0x2a0, 0x27c,
    0x258, 0x235, 0x212, 0x1f1, 0x1d1, 0x1b1, 0x193, 0x175,
    0x159, 0x13e, 0x123, 0x10a, 0xf2, 0xdb, 0xc5, 0xb0,
    0x9c, 0x89, 0x78, 0x67, 0x58, 0x4a, 0x3d, 0x32,
    0x27, 0x1e, 0x16, 0xf, 0xa, 0x6, 0x2, 0x1,
    0x0, 0x1, 0x2, 0x6, 0xa, 0xf, 0x16, 0x1e,
    0x27, 0x32, 0x3d, 0x4a, 0x58, 0x67, 0x78, 0x89,
    0x9c, 0xb0, 0xc5, 0xdb, 0xf2, 0x10a, 0x123, 0x13e,
    0x159, 0x175, 0x193, 0x1b1, 0x1d1, 0x1f1, 0x212, 0x235,
    0x258, 0x27c, 0x2a0, 0x2c6, 0x2ed, 0x314, 0x33c, 0x365,
    0x38e, 0x3b8, 0x3e3, 0x40e, 0x43a, 0x467, 0x494, 0x4c2,
    0x4f0, 0x51f, 0x54e, 0x57d, 0x5ad, 0x5dd, 0x60e, 0x63f,
    0x670, 0x6a1, 0x6d3, 0x705, 0x737, 0x769, 0x79b, 0x7cd
};

// Lookup table for triangle wave generation
uint16_t triangleTable[256] = {
    0x10, 0x20, 0x30, 0x40, 0x50, 0x60, 0x70, 0x80,
    0x90, 0xa0, 0xb0, 0xc0, 0xd0, 0xe0, 0xf0, 0x100,
    0x110, 0x120, 0x130, 0x140, 0x150, 0x160, 0x170, 0x180,
    0x190, 0x1a0, 0x1b0, 0x1c0, 0x1d0, 0x1e0, 0x1f0, 0x200,
    0x210, 0x220, 0x230, 0x240, 0x250, 0x260, 0x270, 0x280,
    0x290, 0x2a0, 0x2b0, 0x2c0, 0x2d0, 0x2e0, 0x2f0, 0x300,
    0x310, 0x320, 0x330, 0x340, 0x350, 0x360, 0x370, 0x380,
    0x390, 0x3a0, 0x3b0, 0x3c0, 0x3d0, 0x3e0, 0x3f0, 0x400,
    0x40f, 0x41f, 0x42f, 0x43f, 0x44f, 0x45f, 0x46f, 0x47f,
    0x48f, 0x49f, 0x4af, 0x4bf, 0x4cf, 0x4df, 0x4ef, 0x4ff,
    0x50f, 0x51f, 0x52f, 0x53f, 0x54f, 0x55f, 0x56f, 0x57f,
    0x58f, 0x59f, 0x5af, 0x5bf, 0x5cf, 0x5df, 0x5ef, 0x5ff,
    0x60f, 0x61f, 0x62f, 0x63f, 0x64f, 0x65f, 0x66f, 0x67f,
    0x68f, 0x69f, 0x6af, 0x6bf, 0x6cf, 0x6df, 0x6ef, 0x6ff,
    0x70f, 0x71f, 0x72f, 0x73f, 0x74f, 0x75f, 0x76f, 0x77f,
    0x78f, 0x79f, 0x7af, 0x7bf, 0x7cf, 0x7df, 0x7ef, 0x7ff,
    0x7ef, 0x7df, 0x7cf, 0x7bf, 0x7af, 0x79f, 0x78f, 0x77f,
    0x76f, 0x75f, 0x74f, 0x73f, 0x72f, 0x71f, 0x70f, 0x6ff,
    0x6ef, 0x6df, 0x6cf, 0x6bf, 0x6af, 0x69f, 0x68f, 0x67f,
    0x66f, 0x65f, 0x64f, 0x63f, 0x62f, 0x61f, 0x60f, 0x5ff,
    0x5ef, 0x5df, 0x5cf, 0x5bf, 0x5af, 0x59f, 0x58f, 0x57f,
    0x56f, 0x55f, 0x54f, 0x53f, 0x52f, 0x51f, 0x50f, 0x4ff,
    0x4ef, 0x4df, 0x4cf, 0x4bf, 0x4af, 0x49f, 0x48f, 0x47f,
    0x46f, 0x45f, 0x44f, 0x43f, 0x42f, 0x41f, 0x40f, 0x400,
    0x3f0, 0x3e0, 0x3d0, 0x3c0, 0x3b0, 0x3a0, 0x390, 0x380,
    0x370, 0x360, 0x350, 0x340, 0x330, 0x320, 0x310, 0x300,
    0x2f0, 0x2e0, 0x2d0, 0x2c0, 0x2b0, 0x2a0, 0x290, 0x280,
    0x270, 0x260, 0x250, 0x240, 0x230, 0x220, 0x210, 0x200,
    0x1f0, 0x1e0, 0x1d0, 0x1c0, 0x1b0, 0x1a0, 0x190, 0x180,
    0x170, 0x160, 0x150, 0x140, 0x130, 0x120, 0x110, 0x100,
    0xf0, 0xe0, 0xd0, 0xc0, 0xb0, 0xa0, 0x90, 0x80,
    0x70, 0x60, 0x50, 0x40, 0x30, 0x20, 0x10, 0x0
};

void dac_init(void){
    // Initialize DAC for single channel operation on channel 0
	DACA.CTRLB = DAC_CHSEL_SINGLE_gc | DAC_CH0TRIG_bm; // single channel operation on ch0
	
    // Set reference voltage to AREFB (2.5V) for DAC
	DACA.CTRLC = DAC_REFSEL_AREFB_gc; //use port b as ref V (2.5)
		
    // Enable DAC output for channel 0
	DACA.CTRLA = DAC_CH0EN_bm | DAC_ENABLE_bm; //enable DAC output for ch0
	
    // No event system configuration
	DACA.EVCTRL = 0x00;	
}

void dac_init_ch1(void){
    // Initialize DAC for single channel operation on channel 1
	DACA.CTRLB = DAC_CHSEL_SINGLE1_gc | DAC_CH1TRIG_bm; // single channel operation on ch1
	
    // Set reference voltage to AREFB (2.5V) for DAC
	DACA.CTRLC = DAC_REFSEL_AREFB_gc; //use port b as ref V (2.5)
	
    // Enable DAC output for channel 1
	DACA.CTRLA = DAC_CH1EN_bm | DAC_ENABLE_bm; //enable DAC output for ch1
	
    // No event system configuration
	DACA.EVCTRL = 0x00;
}

void tcc0_init(void){
    // Configure Timer/Counter for overflow interrupt at ~1567 Hz
	TCC0.PER = (((32000000 / 8) / 1567) / 256); //should be about 1567 Hz -> (((32000000 / 8) / 1567) / 256)
		
    // Set event system channel to trigger on Timer/Counter 0 overflow
	EVSYS.CH0MUX = EVSYS_CHMUX_TCC0_OVF_gc;

    // Select Timer/Counter 0 clock source with a prescaler of 8
	TCC0.CTRLA |= TC_CLKSEL_DIV8_gc;
}

void tcc1_init(void){
    // Configure Timer/Counter 1 for overflow interrupt
	TCC1.PER = (8250);
	
    // Set Timer/Counter 1 overflow interrupt level to low
	TCC1.INTCTRLA = TC_OVFINTLVL_LO_gc; 
	
    // Set event system channel to trigger on Timer/Counter 0 overflow
	EVSYS.CH0MUX = EVSYS_CHMUX_TCC0_OVF_gc;

    // Select Timer/Counter 1 clock source with a prescaler of 1024
	TCC1.CTRLA |= TC_CLKSEL_DIV1024_gc;
	
    // Enable low and medium level interrupts for the PMIC
	PMIC.CTRL = PMIC_LOLVLEN_bm | PMIC_MEDLVLEN_bm;
	
    // Enable global interrupts
	sei();
}

void usart_init(void){
    // Configure TxD and RxD pins
	PORTD.OUTSET = PIN3_bm;
	PORTD.DIRSET = PIN3_bm;
	PORTD.DIRCLR = PIN2_bm;

    // Configure USART for 116,500 baud rate
	USARTD0.BAUDCTRLA = (uint8_t)32;
	USARTD0.BAUDCTRLB = (uint8_t)((-1 << 4)|(32 >> 8));

    // Configure USART with 8 data bits, odd parity, and one stop bit
	USARTD0.CTRLC =	(USART_CMODE_ASYNCHRONOUS_gc |
					 USART_PMODE_DISABLED_gc 	 |
					 USART_CHSIZE_8BIT_gc)       &
					~USART_SBMODE_bm;

    // Enable receiver and transmitter
	USARTD0.CTRLB = USART_RXEN_bm | USART_TXEN_bm;

    // Set USART receive complete interrupt level to medium
	USARTD0.CTRLA = USART_RXCINTLVL_MED_gc; 
}
